

        本質その１  ＝   " JavaScriptの関数は定義時のコンテキストで実行される "


ここでいう「コンテキスト」とは、「状況・文脈」という意味であり、「その関数が参照可能な外部変数」　のこと
そして、「定義時の」というのは、関数の実行時ではなく、あくまでその関数が定義されたタイミング、を表している

つまりこれらを纏めると、「関数が、定義されたタイミングで参照していた外部変数、それを保持した状態で、関数が実行される」、ということになり
言い換えると、「どこで実行されようとも、自分を定義した関数を親とする」、という意味になる、これを「レキシカルシコープ」と呼ぶ

これをシンプルに表したものが以下のコードになる

- - - - - - - - - -
var scope = 'global';
 
function func1() {
    console.log(scope);
}
 
function func2() {
    var scope = 'local';
 
    func1();
}
 
func1();
func2();

// 結果
global
global
- - - - - - - - - -

func1は外部変数「scope」の値を出力する
定義時のscopeの値は’global’なので、func1の実行結果は「global」になる

次に、func1をfunc2の内部で実行している
このタイミングではfunc1の外部変数scopeの値は’local’になっているにもかかわらず、ここで出力される値は’global’となる

これにより、関数はいかなるタイミングや場所で実行されようとも、定義時のコンテキスト（文脈）で実行される、というのがわかる





        本質その２   ＝   " JavaScriptの関数は第１級オブジェクトである "


第１級オブジェクトとは、変数に格納したり、他の関数の引数として渡すことができるオブジェクトのこと

なので、「JavaScriptの関数は変数として持ち運ぶ」、ことが可能であり、
定義されたコンテキストとは、異なるコンテキスト上で実行できることを示している

例えば次のコードのような使い方ができる

- - - - - - - - - -
var funcA = function() {
        console.log('funcA Called!!');
};

var funcB = function (fn) {
        fn();
};

funcB(funcA);

// 結果
funcA Called!!
- - - - - - - - - -

funcAは、定義されているのはグローバル上だが、実行時は、呼び出されたfuncBのスコープの中で実行されている
つまり、「関数はどこにでも持ち出せるが、あくまでも定義時のコンテキストで実行される」ということが言える

「JavaScriptの関数は変数として持ち運べる」、ということを分かり易くするために、下にもうひとつの例を出す

- - - - - - - - - -
// 通常の関数
function hello() {
  // 関数の内部の関数
  function child() {
    console.log('私、helloの子供だよ')
  }
  return child;
}

// hello()の戻り値を「x」に代入する
const x = hello();
console.log(x);
x();

// 結果
ƒunction child() {
    console.log('私、helloの子供だよ')
}
私、helloの子供だよ
- - - - - - - - - -

変数x　には、hello()の戻り値である、変数childが代入されている
それをコンソールで表示すると、変数childに格納された関数が映し出され、x()をそのまま実行することで、関数childが実行されている

これにより、JavaScriptの関数は変数として持ち運べることがわかる






		本質その３	＝	" JavaScriptの関数は、親の関数の変数を使える "


通常、一方の関数から他方の関数の変数を使うことはできない
ただし、関数同士が親子関係にある場合にのみ、子供から親（親以上）の変数を使うことはできる

しかし、親から子供の変数を使うことはできないので注意する







		本質その４	＝	" 関数は定義時のコンテキストとは異なるコンテキスト上に持ち出されると、クロージャになる "


- - - - - - - - - -
var createCounter = function () {
        var cnt = 0;
 
        return function child() {
            cnt += 1;
            console.log(cnt);
        };
    };

var counter = createCounter();
counter(); // 「1」が出力される
counter(); // 「2」が出力される
counter(); // 「3」が出力される
- - - - - - - - - -

createCounter()は、その内部で新たに関数を定義して、その関数を戻り値として返している
そしてcreateCounter()により作成された関数childが、変数counterに格納されている

普通に考えたら、コードの136行目でcreateCounter()の実行が完了しているので、その内部変数であるcntは破棄されてしまい、
参照対象としての変数cntが消滅したことにより、child()が変数cntを使えなくなってしまうかのように思える

しかし、結果を見ても明らかに変数cntは保持され続けている
これは、変数counterに代入されたchild()が、実行時ではなく、定義時のコンテキストを保持した状態で実行されているからである

これにより、親のcreateCounter()の変数である「cnt = 0」を保持しながら、counter()が呼ばれるたびに、関数childの処理だけが実行されることにより、
「変数cntが初期化されることなく、また変数cntを保持しながら」、処理を実行する、というような現象が起こっている

（小休止）

child()が定義されたときのコンテキストと、変数counterのコンテキスト（グローバルスコープ）は異なっている
そのような、関数と、その関数が定義されたコンテキストを保持した特殊なオブジェクトを「クロージャ」といい、child()を、変数counterに代入されることにより、作成することができる






