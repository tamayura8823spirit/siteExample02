

        ==  基本  ==


[ 例文 ]

var numbers = [2, 5, 100, 4];

numbers.sort(function (a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
});

console.log(numbers);


// 結果
[2, 4, 5, 100]


ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー


[ 解説 ]

  ① 引数にある a,b って何？
配列の中の要素のうちの1つが" a "、次の1つが" b "に代入されている
sort()で数値を比較するときは、必ずこの2つを取るが、名前は別に「a」や「b」じゃなくてもいい

例えば、numbersにある 「2」 を a、次の要素である "5" を b に入れてみる
2と5を比較すると 「２ < ５」 となり、 「a < b」 の条件を満たすので、 "return -1" の方を通る

また 「100をa」 , 「4をb」 とすると、 「100 > 4」 となり、 「a > b」 の条件を満たすので、 "return 1" の方を通る

このように、 "a" には配列のうちの1つの要素、 "b" には次の要素が入ることで、その2つの数字の大小を比較している
「aとbは配列の中の要素なんだな」、ということを覚えておく


　 - - - - -


  ② return -1 とか return 1 って何？
これを知るために、まずはsort()について知っておく必要がある
sort()は、以下のルールに従って並び替えをしている

ーーーーーーーーーーーーーーーーーーー
０より小さい  ｜   a を前に移動
０         ｜   順序の変更をしない
０より大きい  ｜   b を前に移動
ーーーーーーーーーーーーーーーーーーー

例えばaに100, bに4が入っている場合、正しい順番に並び替えるには b を a の前に来させる必要がある
そして、そのためにはコールバック関数で "0より大きい値" を返せばいいということになる

この 「0より大きい値を返せばいい」 という部分が、
else if (a > b) { return 1; }   に相当している

aとbを比較し、aの方が大きければ "return 1" を返すことで、sort関数が b を a の前に持ってきてくれる

また、aが2、bが5だった場合は、
if (a < b) { return -1; }   を通るので、 "a" を前に移動している （そのままの順番）
なお、a と b どちらも同じ場合は、  else { return 0; }  を通るので、sort関数は何もしない


つまり、 "return -1" や "return 1" 自体に特別な意味があるわけではなく、
sort関数で並び替え処理するために必要な処理、というだけ

別に、returnの値は 1 や -1 でなくても、 3 とか -100 でも全然いい



ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー



        ==  降順で並び替える  ==
        
        
[ 例文 ]

var numbers = [2, 5, 100, 4];

numbers.sort(function (a, b) {
  if (a > b) {
    return -1;
  } else if (a < b) {
    return 1;
  } else {
    return 0;
  }
});

console.log(numbers);


// 結果
[100, 5, 4, 2]


// 解説
前のコードと違う部分は、if文の比較演算子が逆になっていること
例えばaが2、bが5の場合、  else if (a < b) { return 1; }   の処理を通る



ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー



        ==  簡潔に書く  ==


[ 例文 ]

var numbers = [2, 5, 100, 4];

numbers.sort(function (a, b) {
  return a - b;
});

console.log(numbers);


// 結果
[2, 4, 5, 100]


ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー


[ 解説 ]
このような書き方でも結果は全く同じになる

やっていることは今までと同じで、引数aには配列のうちの1つの要素、bには次の要素が入る
そして、sort()は戻り値が0未満なら順番は変わらない、0より大きいなら順番を入れ替えるという処理をする

仮にaが2、bが5だった場合、
「2 – 5 = -3」 となり、戻り値は0未満なので順番は変わらない

これを繰り返すことで並び替えができる、配列の中に負の数が入っていても正しくソートできる
「return -1 や return 1 自体に特別な意味があるわけではない」 と前述した理由はこれ、要は正の数と負の数のどちらかが返っていればいいので、上のような書き方になる



ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー



        ==  数値じゃなくてもいい  ==


[ 例文 ]

var array = ['hoge', 'foo', 'fugafuga', 'bar'];

array.sort(function (a, b) {
  return a.length - b.length;
});

console.log(array);

// 結果
["foo", "bar", "hoge", "fugafuga"]


// 解説
sort()で並び替えをする場合、比較するのは数値の大小だけじゃなく、インデックス番号や文字列の長さなど、正直何でもいい
上のサンプルは、文字列の長さでソートするプログラムで、文字数が少ない順に並び替えができている



ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー



        ==  オブジェクトのプロパティを元にする  ==


[ 例文 ]

var people = [
  { name: '山田', id: 8 },
  { name: '田中', id: 2 },
  { name: '佐藤', id: 1 },
  { name: '鈴木', id: 5 },
];

people.sort(function (a, b) {
  return a.id - b.id;
});

console.log(people);


// 結果
[
  {name: "佐藤", id: 1}
  {name: "田中", id: 2}
  {name: "鈴木", id: 5}
  {name: "山田", id: 8}
]


