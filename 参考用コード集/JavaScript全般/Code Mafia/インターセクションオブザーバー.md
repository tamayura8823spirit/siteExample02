

# インターセクションオブザーバー
Intersection（**交差を**）Observer（**監視する者**）という意味を持つ、  
画面のスクロールに応じて JavaScript を実行させるクラス
```rb
const io = new IntersectionObserver( コールバック関数 ) ;
```
<br>

### まずインスタンス化した **io** に監視したいDOMを登録する
```yml
const 監視対象 = document.querySelector('タグ名');
io.observe( 監視対象 ) ;
io.observe( 監視対象2 ) ; 
```
このようにしてあげると、監視対象が**画面内に入ったとき**と、**画面内から出ていくとき**に、「コールバック関数」が呼ばれるようになる。   
監視対象は**複数**を設定することもできる。   

<br>

### 「入ったとき」「出たとき」の定義を明確にする
```yml
const コールバック関数 = function(entries, observer) {
  entries.forEach(entry => { 処理 })
}
```
コールバック関数には、`entries`と`observer`という２つの引数を取ることができ、  
`entries`を`forEach()`メソッドで回すことで、すべての要素に処理をさせることができる。  

<br>

### 監視をやめたい場合
```yml
observer.unobserve(entry.target)
```
`observer.unobserve()`メソッドに、`entry.target`を格納することで、監視を終了することができる。  
`entry.target`には登録したDOM（**監視対象**）が格納されており、それを再び代入することで停止させている。  

<br><br>

## コード例
```4D
const child = document.querySelector('.child');
const cb = function(entries, observer) {
  entries.forEach(entry => {                    •••••• ①
    if(entry.isIntersecting) {                  •••••• ②
      console.log('inview');
      observer.unobserve(entry.target);         •••••• ③
    } else {
      console.log('out view');
    }
  })
}
const io = new IntersectionObserver(cb);
io.observe(child);
io.observe(child2);
io.observe(child3);
```

①　`entry` がそれぞれの要素（`child`、`child2`、`child3`）を意味する。

②　`isIntersecting` というプロパティが、`true` のときは要素が「入った状態」を意味し、`false` の場合は「出たとき」を意味する。  

③　入ったタイミングで**停止信号**を送っているので、再びメッセージが表示されることは無い。  


