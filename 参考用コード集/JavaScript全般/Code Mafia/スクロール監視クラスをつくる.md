
## スクロール監視クラスをつくる
```
```

①　対象の**DOM要素**を変数（プロパティ）に格納する。  

<br>

②　「スクロールを監視する処理」を**コンストラクター内**に直接記述するよりも、  
`_init()` メソッドを別に用意してあげて、こちらを初期化処理として記述してやる。  

<br>

```4D
constructor() {
    const cb = function (entries, observer) {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                observer.unobserve(entry.target);
            } else {
            }
        });
    };
}
```
 ↑ はあまり良くない例で、  
 基本的にコンストラクター内で定義するものは、**`this` のプロパティに値を設定するものだけ**にしたほうがいい。  

プロパティの値を全部格納し終わってから、複雑な初期化処理を一番最後に呼ぶことで、  
**変数の定義漏れなどを防ぎ**、**バグが混入しにくくなる。**  

<br>

③　デフォルトのオプションを設定するために、`constructor()` の第二引数に**コールバック関数**、第三引数に **`options`** を取る。  

`options` と `defaultOption` を**纏めたもの**を後々インターセクションオブザーバーに渡したいので、  
そうするために **`Object.assign()`** を使ってその２つをマージさせる。  

>  【**Object.assign**】  
> 第１引数のオブジェクトに、第２引数のオブジェクトをを**マージ**させる  
> ２つのオブジェクトが同じプロパティを持っている場合、**その値は上書きされる**  

<br>

これで、後に設定したオブジェクトに同じプロパティがあった場合には、その値で上書きされたものが `this.options` にセットされる。  

<br>

④　`IntersectionObserver()` をインスタンス化させる処理を `_init()` 内に記述する。  

その際、 `this.options` を第２引数にすることで、クラス内のオプションを参照することができる。  
また第１引数に関しても、`_init()` 内で定義した `callback()` 関数を設定してあげる。  

<br>

⑤　あとは、`constructor()` の第２引数のコールバック関数を `_init()` 内で呼び出したいので、  
コールバック関数を `this.cb` にひとまず格納して、それを中で呼び出してあげる。  

第１引数に**監視しているDOM**（`entry.target`）を渡してあげて、  
第２引数に今回の場合は、「**交差しているか、していないか**」を `true` `false` で渡してあげる。  

このように、コールバック関数内でも「**交差しているか、していないか**」を判定できるようにすることで、  
より柔軟性のあるクラスの使用方法が可能になる。  


<br>


⑦　`this.cb` の `this` が、`IntersectionObserver()` 内では「**windowオブジェクト**」になってしまうので、  
thisの `bind` で**束縛**してやる必要がある。  

>  【 **メモ** 】  
> IntersectionObserver() は window オブジェクトのクラスになるので、  
> **その中のthis**は、window オブジェクトを取る  

<br>

これで `this` は `ScrollObserver()` のことを参照するので、問題なく通ることになる。  












